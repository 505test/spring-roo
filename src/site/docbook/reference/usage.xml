<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="usage" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>Usage and Conventions</title>

  <para>In this chapter we'll introduce how to use the Roo tool itself. We'll
  cover typical conventions you'll experience when using Spring Roo.</para>

  <section xml:id="usage-usability">
    <title>Usability Philosophy</title>

    <para>As mentioned in earlier chapters and is easily experienced by simply
    using Spring Roo for a project, we placed a great deal of emphasis on
    usability during Roo's design. It is our experience that a normal
    enterprise Java developer is able to pass the ten minute test with Roo and
    build a new project without referring to documentation. There are several
    conventions that we use within Roo to ensure a highly usable
    experience:</para>

    <itemizedlist>
      <listitem>
        <para>Numerous <link linkend="usage-shell">shell features</link> which
        ensure the primary Roo-specific user interface is friendly and
        learnable</para>
      </listitem>

      <listitem>
        <para>Only using popular, <link
        linkend="intro-why-use-it-standard-java">mainstream technologies and
        standards</link> within Roo applications</para>
      </listitem>

      <listitem>
        <para>Ensuring Roo works with your <link linkend="usage-ide">choice of
        IDE</link> or no IDE at all</para>
      </listitem>

      <listitem>
        <para>Delivering an <link linkend="architecture">application
        architecture</link> that is easy to understand and avoids
        "magic"</para>
      </listitem>

      <listitem>
        <para>Making sure Roo works the way a reasonable person would expect
        it to</para>
      </listitem>

      <listitem>
        <para>Forgiving mistakes</para>
      </listitem>
    </itemizedlist>

    <para>The last two points are what we're going to discuss in this
    section.</para>

    <para>Making sure Roo works the way you would expect it to is reflected in
    a number of key design decisions that basically boil down to "you can do
    whatever you want, whenever you want, and Roo will automatically work in
    with you". There are obviously limits to how far we can take this, but as
    you use Roo you'll notice a few operational conventions that underpin
    this.</para>

    <para>Let's start by looking at file conventions. Roo will never change a
    <code>.java</code> file in your project unless you explicitly ask it to
    via a shell command. In particular, Roo will not modify a
    <code>.java</code> file just because you apply an annotation. Roo also
    handles .xml and .properties files in the same manner. There are only two
    file types that may be created, updated or deleted by Roo in an automatic
    manner, those being <code>.jspx</code> files and also AspectJ files which
    match the <code>*_Roo_*.aj</code> wildcard.</para>

    <para>Does this mean Roo will randomly go across your project changing
    <code>.jspx</code> and AspectJ files that match this syntax? Certainly
    not. Roo will only ever modify a <code>.jspx</code> file if the
    corresponding web controller contains the <code>@RooWebScaffold</code>
    annotation and that annotation has the attribute
    <code>automaticallyMaintainView=true</code> (which is also the default if
    the annotation attribute is not explicitly specified). In terms of the
    AspectJ files, Roo operates in a very specific manner. A given AspectJ
    filename indicates the "target type" the members will be introduced into
    and also the add-on which governs the file. Roo will only ever permit a
    given AspectJ file to be preserved if the target type exists and the
    corresponding add-on requests an ITD for that target type. Nearly all
    add-ons will only create an ITD if there is a "trigger annotation" on the
    target type, with the trigger annotation always incorporation an @Roo
    prefix. As such, if you never put any @Roo annotation on a given .java
    file, you can be assured Roo will never create any AspectJ ITD for that
    target type. Refer to the <link linkend="usage-file-system">file system
    conventions</link> section for related information.</para>

    <para>You'll also notice when using Roo that is automatically responds to
    changes you make outside Roo. This is achieved by an <link
    linkend="command-index-poll-status">auto-scaling file system
    monitoring</link> mechanism. This basically allows you to create, edit or
    delete any file within your project and if the Roo shell is running it
    will immediately detect your change and take the necessary action in
    response. This is how round-tripping works without you needing to include
    Roo as part of your build system or undertake any crude mass generation
    steps.</para>

    <para>What happens if the Roo shell isn't running? Will there be a problem
    if you forget to load it and make a change? No. When Roo starts up it
    performs a full scan of your full project file system and ensures every
    automatically-managed file that should be created, updated or deleted is
    handled accordingly. This includes a full in-memory rebuild of each file,
    and a comparison with the file on disk to detect changes. This results in
    a lot more robust approach than relying on relatively coarsely-grained
    file system timestamp models. It also explains why if you have a very big
    project it can take a few moments for the Roo shell to startup, as there
    is no alternative but to complete this check for actions that happened
    when Roo wasn't running.</para>

    <para>The automated startup-time scan is also very useful as you upgrade
    to newer versions of Roo. Often a new version of Roo will incorporate
    enhancements to the add-ons that generate files in your project. The
    startup-time scan will therefore automatically deliver improvements to all
    generated files. This is also why you cannot edit files that Roo is
    responsible for managing, because Roo will simply consider your changes as
    some "old format" of the file and rewrite the file in accordance with its
    current add-ons.</para>

    <para>Not being able to edit the generated files may sound restrictive, as
    often you'll want to fine-tune just some part of the file that Roo has
    emitted. In this case you can either write a Roo add-on, or more commonly
    just write the method (or field or constructor etc) directly in your .java
    file. Roo has a convention of detecting if any member it intends to
    introduce already exists in the target type, and if it does Roo will not
    permit the ITD to include that member. In plain English that means if you
    write a method that Roo was writing, Roo will remove the method from its
    generated file automatically and without needing an explicit directive to
    do so. In fact the Roo core infrastructure explicitly detects buggy
    add-ons that are trying to introduce members that an end user has written
    and it will throw an exception to prevent the add-on from doing so.</para>

    <para>This talk of exceptions also lets us cover the related usability
    feature of being forgiving. Every time Roo changes your file system or
    receive a shell command, it is executed within a quasi-transactional
    context that supports rollback. As a result, if anything goes wrong (such
    as you made a mistake when entering a command or an add-on has a problem
    for whatever reason) the file system will automatically rollback to the
    state it was before the change was attempted. The cascading nature of many
    changes (ie you add a field to a <code>.java</code> file and that changes
    an AspectJ ITD and that in turn changes a web <code>.jspx</code> etc) is
    handled in the same unit of work and therefore rolled back as an atomic
    group when required.</para>

    <para>Before leaving this discussion on usability, it's probably worth
    pointing out that although the Roo shell contains <link
    linkend="command-index">numerous commands</link>, you don't need to use
    them. You are perfectly free to perform any change to your file system by
    hand (without the help of the Roo shell). For example, there are commands
    which let you create <code>.java</code> files or add fields to them. You
    can use these commands or you can simply do this within your IDE or text
    editor. Roo's automatic file system monitoring will detect the changes and
    respond accordingly. Just work the way you feel most comfortable - Roo
    will respect it.</para>
  </section>

  <section xml:id="usage-shell">
    <title>Shell Features</title>

    <para>Many people who first look at Roo love the shell. In fact when we
    first showed Roo to an internal audience, one of the developers present
    said tounge-in-cheek, "That could only have come from someone with a deep
    love of the Linux command line!". All jokes aside, the shell is only one
    part of the Roo <link linkend="usage-usability">usability story</link> -
    although it's a very important part. Here are some of the usability
    features that make the shell so nice to work with:</para>

    <para><itemizedlist>
        <listitem>
          <para><emphasis>Tab completion</emphasis>: The cornerstone of
          command-line usability is tab assist. Hit TAB (or CTRL+SPACE if
          you're in <link linkend="usage-ide">SpringSource Tool Suite</link>)
          and Roo will show you the applicable options.</para>
        </listitem>

        <listitem>
          <para><emphasis>Command hiding</emphasis>: Command hiding will
          remove commands which do not make sense given the current context of
          your project. For example, if you're in an empty directory, you can
          type <link linkend="command-index-project">project</link>, hit TAB,
          and see the options for creating a project. But once you've created
          the project, the project command is no longer visible. The same
          applies for most Roo commands. This is nice as it means you only see
          commands which you can actually use right now. Of course, a full
          list of commands applicable to your version of Roo is available in
          the <link linkend="command-index">command index appendix</link> and
          also via <link linkend="command-index-help">help</link>.</para>
        </listitem>

        <listitem>
          <para><emphasis>Contextual awareness</emphasis>: Roo remembers the
          last Java type you are working with in your current shell session
          and automatically treats it as the argument to a command. You always
          know what Roo considers the current context because the shell prompt
          will indicate this just before it writes <emphasis
          role="bold">roo&gt;</emphasis>. In the command index you might find
          some options which have a default value of '<code>*</code>'. This is
          the marker which indicates "the current context will be used for
          this command option unless you explicitly specify otherwise". You
          change the context by simply working with a different Java type (ie
          specify an operation that involves a different Java type and the
          context will change to that Java type).</para>
        </listitem>

        <listitem>
          <para><emphasis>Hinting</emphasis>: Not sure what to do next? Just
          use the <link linkend="command-index-hint">hint</link> command. It's
          the perfect lightweight substitute for documentation if you're in a
          hurry!</para>
        </listitem>

        <listitem>
          <para><emphasis>Inbuilt help</emphasis>: If you'd like to know all
          the options available for a given command, use the <link
          linkend="command-index-help">help</link> command. It lists every
          option directly within the shell.</para>
        </listitem>

        <listitem>
          <para><emphasis>Automatic inline help</emphasis>: Of course, it's a
          bit of a pain to have to go to the trouble of typing <link
          linkend="command-index-help">help</link> then hitting enter if
          you're in the middle of typing a command. That's why we offer inline
          help, which is automatically displayed whenever you press TAB. It is
          listed just before the completion options. To save screen space, we
          only list the inline help once for a given command option. So if you
          type <code>project --template TAB TAB TAB</code>, the first time you
          press TAB you'd see the inline help and the completio options</para>
        </listitem>

        <listitem>
          <para><emphasis>Scripting and script recording</emphasis>: Save your
          Roo commands and play them again later.</para>
        </listitem>
      </itemizedlist>The scripting and script recording features are
    particularly nice, because they let you execute a series of Roo commands
    without typing them in.</para>

    <para>To execute a Roo script, just use the <link
    linkend="command-index-script">script</link> command. When you use the
    script command you'll need to indicate the script to run. We ship a number
    of sample scripts with Roo, as discussed earlier in the <link
    linkend="intro-exploring-sample">Exploring Roo Samples</link>
    section.</para>

    <para>What if you want to create your own scripts? All you need is a text
    editor. The syntax of the script is identical to what you'd type at the
    Roo shell. Both the Roo shell and your scripts can contain inline comments
    using the <code>;</code> and <code>//</code> markers, as well as block
    comments using the <code>/* */</code> syntax. </para>

    <para>A really nice script-related feature of the Roo shell is that it
    will automatically build a script containing the commands you entered.
    This file is named <code>log.roo</code> and exists in your current working
    directory. Here's a quick example of the contents:</para>

    <programlisting>// Spring Roo ENGINEERING BUILD [rev 553:554M] log opened at 2009-12-31 08:10:58
project --topLevelPackage roo.shell.is.neat
// [failed] persistence setup --database DELIBERATE_ERROR --provider HIBERNATE 
persistence setup --database HYPERSONIC_IN_MEMORY --provider HIBERNATE 
quit
// Spring Roo ENGINEERING BUILD [rev 553:554M] log closed at 2009-12-31 08:11:37</programlisting>

    <para>In the recorded script, you can see the version number, session
    start time and session close times are all listed. Also listed is a
    command I typed that was intentionally incorrect, and Roo has turned that
    command into a comment within the script (prefixed with <code>//
    [failed]</code>) so that I can identify it and it will not execute should
    I run the script again later. This is a great way of reviewing what you've
    done with Roo, and sharing the results with others.</para>
  </section>

  <section xml:id="usage-ide">
    <title>IDE Usage</title>

    <para>Despite Roo's really nice shell, in reality most people develop most
    of their application using an IDE or at least text editor. Roo fully
    expects this usage and supports it.</para>

    <para>Before we cover how to use an IDE, it's worth mentioning that you
    don't strictly need one. With Roo you can build an application at the
    command line, although to be honest you'll get more productivity via an
    IDE if it's anything beyond a trivial application. If you would prefer to
    use the command line, you can start a freash application using the Roo
    shell, edit your <code>.java</code> and other files using any text editor,
    and use the <link linkend="command-index-maven-commands">perform</link>
    commands to compile, test and package your application ready for
    deployment. You can even use <code>mvn tomcat:run</code> to execute a
    servlet container, and Roo add-ons let you deploy straight to a cloud
    environment like <link xlink:href="http://www.cloudfoundry.com/">Cloud
    Foundry</link>. Again, you'll be more productive in an IDE, but it's nice
    to know Roo doesn't force you to use an IDE unless you'd like to use
    one.</para>

    <para>In relation to IDEs, we highly recommend that you use <link
    xlink:href="http://www.springsource.com/products/sts">SpringSource Tool
    Suite</link>. STS is a significantly extended version (and free!) of the
    pervasive Eclipse IDE. From a Roo perspective, STS preintegrates the
    latest <link xlink:href="http://www.eclipse.org/ajdt/">AspectJ Development
    Tools</link> (AJDT) and also offers an inbuilt Roo shell. The inbuilt Roo
    shell means you do not need to run the normal Roo shell if you are using
    STS. You'll also have other neat Roo-IDE integation features, like the
    ability to press CTRL+G (or Apple+G if you're on an Apple) and a popup
    will allow you to type a Roo command from anywhere within the IDE. Another
    nice feature is the shell message hotlinking, which means all shell
    messages emitted by Roo are actually links that you can click to open the
    corresponding file in an Eclipse editor. There are other goodies too, like
    extra commands to deploy to SpringSource tc Server.</para>

    <para>Naturally Roo works well with standard Eclipse as well. All you need
    to do is ensure you install the latest <link
    xlink:href="http://www.eclipse.org/ajdt/">AspectJ Development Tools</link>
    (AJDT) plugin. This will ensure code assist and incremental compilation
    works well. We also recommend you go into Window &gt; Preferences &gt;
    General &gt; Workspace and switch on the "Refresh automatically" box. That
    way Eclipse will detect changes made to the file systme by the
    externally-running Roo shell.</para>

    <para>If you're using IntelliJ, we recommend you review IntelliJ issue
    report <link
    xlink:href="http://youtrack.jetbrains.net/issue/IDEA-26959">IDEA-26959</link>
    and consider voting on it. This issue report represents an IntelliJ
    community request for full Aspect ITD support in IntelliJ. As shown in the
    issue report, the AspectJ, AJDT and Roo project leads (all of whom who
    work for the SpringSource division of VMware) have offered to assist
    IntelliJ in securing ITD support. In the meantime you can use IntelliJ
    with Roo applications, but IDEA-26959 will make your experience much
    smoother.</para>

    <para>If you're using any IDE other than STS, the recommended operating
    pattern is to load the standalone Roo shell in one operating system window
    and leave it running while you interact with your IDE. There is no formal
    link between the IDE and Roo shell. The only way they "talk" to each other
    is by both monitoring the file system for changes made by the other. This
    happens so quickly that you're unlikely to notice, and indeed internally
    to Roo we have an API that allows the polling-based approach to be
    replaced with a formal notification API should it ever become necessary.
    As discussed in the <link linkend="usage-usability">usability
    section</link>, if you forget to load the Roo shell and start modifying
    your project anyway, all you need to do is load the Roo shell again and it
    will detect any changes it needs to make automatically.</para>
  </section>

  <section xml:id="usage-build-system">
    <title>Build System Usage</title>

    <para></para>
  </section>

  <section xml:id="usage-file-system">
    <title>File System Conventions</title>

    <para>Cover version control recommendations, plus handling of changes if
    Roo isn't running. Also the auto-scaled file monitoring in use etc. Also
    backup command. The only files that Roo automatically maintains are
    AspectJ ITDs matching the <code>*_Roo_*.aj</code> wildcard and those JSPs
    associated with MVC controllers that have the annotation
    <code>@RooWebScaffold(automaticallyMaintainView=true)</code>.</para>
  </section>

  <section xml:id="usage-addons">
    <title>Add-On Installation and Removal</title>

    <para>TBC</para>
  </section>

  <section xml:id="usage-recommendations">
    <title>Recommended Practices</title>

    <para>TBC</para>
  </section>

  <section xml:id="usage-diagnosis">
    <title>Diagnosing Roo Problems</title>

    <para>TBC</para>
  </section>

  <section xml:id="usage-known-issues">
    <title>Known Issues</title>

    <para>TBC</para>
  </section>
</chapter>
